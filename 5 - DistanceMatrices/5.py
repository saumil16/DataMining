# -*- coding: utf-8 -*-
"""DataMining_Lab5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fZw5QYcdmWHXqyrYUqKjpwD-NIU56LSh
"""

import random as ra
import numpy as np
import matplotlib.pyplot as plt

x1 = ra.randrange(100)
y1 = ra.randrange(100)
x2 = ra.randrange(100)
y2 = ra.randrange(100)
print("Point 1 : ",x1,",",y1)
print("Point 2 : ",x2,",",y2)

point1 = [x1,x2]
point2 = [y1,y2]

p1 = np.array((x1,y1))
p2 = np.array((x2,y2))

# Eulcidean distance matrix (PLOT)
#Euclidean Distance (Euclidean distance is the straight-line distance between two points)

res = np.sum(np.square(p1 - p2))
ans = np.sqrt(res)
print("Euclidean Distance : ",ans)

plt.plot(point1,point2,marker="o",markerfacecolor="blue",color="green")
plt.show()

# Manhattan Distance matrix (PLOT)
# Manhattan distance (Manhattan distance is the sum of the absolute differences between coordinates)

def manhattan_distance(point1, point2):
  return abs(x1-x2)+abs(y1-y2)

dist = manhattan_distance(point1,point2)
print("Manhattan Distance : ",dist)

plt.plot([point1[0], point2[0]], [point1[1], point1[1]], 'r--', label=f"x distance: {abs(point2[0] - point1[0])}")
plt.plot([point2[0], point2[0]], [point1[1], point2[1]], 'g--', label=f"y distance: {abs(point2[1] - point1[1])}")

plt.scatter([point1[0], point2[0]], [point1[1], point2[1]], color='blue', zorder=5)
plt.legend()
plt.title('Manhattan Distance')
plt.grid(True)
plt.show()

"""Minkowski distance is a metric in a normed vector space. Minkowski distance is used for distance similarity of vector. Given two or more vectors, find distance similarity of these vectors.

![image.png](data:image/png;base64,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)
"""

# Minkowski distance
from scipy.spatial import distance

p=np.random.randint(1,10)

def minkowski_distance(point1, point2):
  return distance.minkowski(point1, point2, p)

print("X = ", p1)
print("Y = ", p2)
res = minkowski_distance(p1, p2)
print("Minkowski Distance:",res)
plt.plot(p1,p2,marker="o",markerfacecolor="green")
plt.show()

"""Cosine similarity is a measure of similarity, often used to measure document similarity in text analysis. We use the below formula to compute the cosine similarity.

Similarity = (A.B) / (||A||.||B||)

where A and B are vectors:

    A.B is dot product of A and B: It is computed as sum of element-wise product of A and B.

    ||A|| is L2 norm of A: It is computed as square root of the sum of squares of elements of the vector A.

"""

# cosine simmilarity
from numpy.linalg import norm

print("X = ", p1)
print("Y = ", p2)
cosine = np.dot(p1,p2)/(norm(p1)*norm(p2))
print("Cosine Similarity:", cosine)
plt.plot(p1,p2,marker="o",markerfacecolor="green")